package main

import (
	"fmt"
	"strconv"
	"strings"
)

func main() {
	num := 1000
	//二进制格式的字符串
	t := strconv.FormatInt(int64(num), 2)
	fmt.Println(t)

	//从后往前，每次按顺序取7位
	res := make([]string, 0)
	for i := len(t); i > 0; i -= 7 {
		start := i - 7
		if start < 0 {
			start = 0
		}
		tmp := t[start:i]
		res = append(res, tmp)
	}

	// fmt.Println(res)

	for i := 0; i < len(res); i++ {
		if i == len(res)-1 {
			//最后一个元素前7位补0
			k := 7 - len(res[i])
			res[i] = "0" + strings.Repeat("0", k) + res[i]
			continue
		}
		//其他元素前面补1
		res[i] = "1" + res[i]
	}
	// fmt.Println(res)
	//将2进制格式的字符串转换为int64
	ans, _ := strconv.ParseInt(strings.Join(res, ""), 2, 0)
	//以大写16进制格式输出
	fmt.Printf("%X\n", ans)

}

/*
   实现一个整数编码方法
   使得待编码的数字越小
   编码后所占用的字节数越小
   编码规则如下
   1.编码时7位一组，每个字节的低7位用于存储待编码数字的补码
   2.字节的最高位表示后续是否还有字节，置1表示后面还有更多的字节，
   置0表示当前字节为最后一个字节
   3.采用小端序编码，低位和低字节放在低地址上
   4.编码结果按16进制数的字符格式进行输出，小写字母需要转化为大写字母

   输入描述
   输入的为一个字符串表示的非负整数
   输出描述
   输出一个字符串表示整数编码的16进制码流

   示例一
   输入
   0
   输出
   00
   说明：输出的16进制字符不足两位的前面补零

   示例二
   输入
   100
   输出
   64
   说明:100的二进制表示为0110 0100只需一个字节进行编码
   字节的最高位0，剩余7位存储数字100的低7位(1100100)所以编码后的输出为64

   示例三
   输入
   1000
   输出
   E807
   说明
   1000的二进制表示为 0011 1110 1000 至少需要两个字节进行编码
   第一个字节最高位是1 剩余7位存储数字 1000的低7位(1101000)
   所以第一个字节的二进制位(1110 1000)即E8
   第二个字节最高位置0 剩余的7位存储数字 1000的第二个低7位(0000111)
   所以第一个字节的二进制为(0000 0111)即07
   采用小端序编码 所以低字节E8输出在前面
   高字节07输出在后面

   备注
       代编码数字取值范围为 [0,1<<64-1]
*/
